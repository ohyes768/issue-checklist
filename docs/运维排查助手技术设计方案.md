# è¿ç»´æ’æŸ¥åŠ©æ‰‹ æŠ€æœ¯è®¾è®¡æ–¹æ¡ˆ

## 1. æ•°æ®æ¨¡å‹è®¾è®¡

### 1.1 æ ¸å¿ƒæ•°æ®ç»“æ„

#### 1.1.1 ChecklistItem æ•°æ®æ¨¡å‹
```python
from dataclasses import dataclass
from typing import List, Optional

@dataclass
class ChecklistItem:
    """æ£€æŸ¥é¡¹ç›®æ•°æ®æ¨¡å‹"""
    status: str           # ç›´æ¥åŸå› ç°è±¡æè¿°
    describe: str         # è¯¦ç»†è¯´æ˜å’Œç¡®è®¤æ–¹æ³•
    priority: int         # ä¼˜å…ˆçº§(1-10ï¼Œæ•°å­—è¶Šå¤§è¶Šé‡è¦)
    version: str          # å½±å“ç‰ˆæœ¬èŒƒå›´
    todo: str            # è§£å†³æ–¹æ¡ˆæè¿°
    checklist: Optional[List['ChecklistItem']] = None  # å­checklist
    refer: Optional[str] = None  # ç›¸å…³é—®é¢˜å¼•ç”¨
    excluded: bool = False  # æ˜¯å¦å·²æ’é™¤è¯¥åŸå› 
    confirmed: bool = False  # æ˜¯å¦å·²ç¡®è®¤è¯¥åŸå› å­˜åœ¨
```

#### 1.1.2 Issue æ•°æ®æ¨¡å‹
```python
@dataclass
class Issue:
    """é—®é¢˜ç°è±¡æ•°æ®æ¨¡å‹ï¼ˆæ”¯æŒé¡¶å±‚priorityå’Œversionï¼‰"""
    file_name: str        # ymlæ–‡ä»¶å
    status: str           # é—®é¢˜ç°è±¡æ ‡é¢˜
    describe: str         # é—®é¢˜æè¿°
    priority: int         # é—®é¢˜æ•´ä½“ä¼˜å…ˆçº§
    version: str          # é—®é¢˜å½±å“ç‰ˆæœ¬
    checklist: List[ChecklistItem]  # ç›´æ¥åŸå› checkliståˆ—è¡¨

    def get_checklist_by_priority(self) -> List[ChecklistItem]:
        """æŒ‰ä¼˜å…ˆçº§é™åºè¿”å›checklist"""
        return sorted(self.checklist, key=lambda x: x.priority, reverse=True)


@dataclass
class TreeChecklistItem:
    """æ ‘å½¢æ£€æŸ¥é¡¹æ•°æ®æ¨¡å‹ï¼ˆæ”¯æŒreferå¼•ç”¨å’Œæ ‘å½¢ç»“æ„ï¼‰"""
    status: str                    # æ˜¾ç¤ºæ ‡é¢˜
    describe: str                  # æè¿°
    priority: int                  # ä¼˜å…ˆçº§
    version: str                   # ç‰ˆæœ¬
    todo: str                      # è§£å†³æ–¹æ¡ˆ
    source_file: str               # æ¥æºymlæ–‡ä»¶
    original_path: List[str]       # åŸå§‹è·¯å¾„ï¼ˆç”¨äºå¯¼èˆªï¼‰
    children: List['TreeChecklistItem'] = field(default_factory=list)  # å­é¡¹
    is_refer: bool = False         # æ˜¯å¦ä¸ºreferå¼•ç”¨çš„é¡¹
    parent_ref: Optional[str] = None  # çˆ¶çº§å¼•ç”¨æ¥æº
```

#### 1.1.3 åº”ç”¨çŠ¶æ€æ¨¡å‹
```python
@dataclass
class AppState:
    """åº”ç”¨çŠ¶æ€ç®¡ç†ï¼ˆæ”¯æŒæ ‘å½¢ç»“æ„ï¼‰"""
    current_issue: Optional[Issue] = None  # å½“å‰é—®é¢˜
    current_tree: Optional[TreeChecklistItem] = None  # å½“å‰æ ‘å½¢ç»“æ„
    current_checklist: Optional[TreeChecklistItem] = None  # å½“å‰æ£€æŸ¥é¡¹
    excluded_items: List[str] = field(default_factory=list)  # å·²æ’é™¤é¡¹ç›®è·¯å¾„
    navigation_path: List[str] = field(default_factory=list)  # å½“å‰å¯¼èˆªè·¯å¾„
    solution_text: Optional[str] = None  # å½“å‰æ˜¾ç¤ºçš„è§£å†³æ–¹æ¡ˆ
    tree_builder: Optional[TreeBuilder] = None  # æ ‘å½¢æ„å»ºå™¨

    def get_current_path_display(self) -> str:
        """è·å–å½“å‰è·¯å¾„çš„æ˜¾ç¤ºæ–‡æœ¬"""
        return " â†’ ".join(self.navigation_path) if self.navigation_path else "æœªé€‰æ‹©"

    def build_current_tree(self):
        """æ„å»ºå½“å‰é—®é¢˜çš„å®Œæ•´æ ‘å½¢ç»“æ„"""
        if self.current_issue and self.tree_builder:
            self.current_tree = self.tree_builder.build_complete_tree(self.current_issue.status)
            return self.current_tree
        return None

    def get_current_checklist_items(self) -> List[TreeChecklistItem]:
        """è·å–å½“å‰å±‚çº§çš„checklisté¡¹"""
        if not self.current_checklist:
            if self.current_tree:
                return sorted(self.current_tree.children, key=lambda x: x.priority, reverse=True)
            return []

        return sorted(self.current_checklist.children, key=lambda x: x.priority, reverse=True)
```

### 1.2 YAMLæ•°æ®è§£æå™¨

#### 1.2.1 DataLoader ç±»è®¾è®¡
```python
import yaml
import os
from pathlib import Path
from typing import Dict

class DataLoader:
    """YAMLæ•°æ®åŠ è½½å’Œè§£æå™¨"""

    def __init__(self, data_dir: str = "data"):
        self.data_dir = Path(data_dir)
        self.issues: Dict[str, Issue] = {}
        self.issue_list: List[str] = []

    def load_all_issues(self) -> Dict[str, Issue]:
        """åŠ è½½æ‰€æœ‰ymlæ–‡ä»¶ä¸­çš„é—®é¢˜æ•°æ®"""
        self.issues.clear()
        self.issue_list.clear()

        for yml_file in self.data_dir.glob("*.yml"):
            issue = self._parse_yml_file(yml_file)
            if issue:
                self.issues[issue.status] = issue
                self.issue_list.append(issue.status)

        return self.issues


class TreeBuilder:
    """æ ‘å½¢ç»“æ„æ„å»ºå™¨ - å¤„ç†referå¼•ç”¨å’Œæ ‘å½¢ç»“æ„æ‹¼æ¥"""

    def __init__(self, data_loader: DataLoader):
        self.data_loader = data_loader
        self.built_trees = {}

    def build_complete_tree(self, root_issue_name: str) -> Optional[TreeChecklistItem]:
        """æ„å»ºå®Œæ•´çš„æ ‘å½¢ç»“æ„"""
        if root_issue_name in self.built_trees:
            return self.built_trees[root_issue_name]

        root_issue = self.data_loader.get_issue_by_name(root_issue_name)
        if not root_issue:
            return None

        # æ„å»ºæ ¹èŠ‚ç‚¹
        root_tree = TreeChecklistItem(
            status=root_issue.status,
            describe=root_issue.describe,
            priority=root_issue.priority,
            version=root_issue.version,
            todo="",  # æ ¹é—®é¢˜æ²¡æœ‰todo
            source_file=root_issue.file_name,
            original_path=[root_issue.status],
            is_refer=False
        )

        # é€’å½’æ„å»ºå­æ ‘
        for item in root_issue.checklist:
            child_tree = self._build_child_tree(item, root_issue.file_name, [root_issue.status])
            if child_tree:
                root_tree.children.append(child_tree)

        # ç¼“å­˜æ„å»ºç»“æœ
        self.built_trees[root_issue_name] = root_tree
        return root_tree

    def _build_child_tree(self, item: ChecklistItem, parent_file: str, path: List[str]) -> Optional[TreeChecklistItem]:
        """æ„å»ºå­æ ‘"""
        if hasattr(item, 'refer') and item.refer:
            # å¤„ç†referå¼•ç”¨
            return self._build_refer_tree(item.refer, parent_file, path)
        else:
            # å¤„ç†æ™®é€šé¡¹
            tree_item = TreeChecklistItem(
                status=item.status,
                describe=item.describe,
                priority=item.priority,
                version=item.version,
                todo=item.todo or "",
                source_file=parent_file,
                original_path=path + [item.status],
                is_refer=False
            )

            # é€’å½’å¤„ç†å­é¡¹
            if hasattr(item, 'checklist') and item.checklist:
                for child_item in item.checklist:
                    child_tree = self._build_child_tree(child_item, parent_file, path + [item.status])
                    if child_tree:
                        tree_item.children.append(child_tree)

            return tree_item

    def _build_refer_tree(self, refer_name: str, parent_file: str, path: List[str]) -> Optional[TreeChecklistItem]:
        """æ„å»ºå¼•ç”¨æ ‘"""
        refer_issue = self.data_loader.get_issue_by_name(refer_name)
        if not refer_issue:
            return None

        # åˆ›å»ºå¼•ç”¨èŠ‚ç‚¹
        refer_tree = TreeChecklistItem(
            status=refer_issue.status,
            describe=refer_issue.describe,
            priority=refer_issue.priority,
            version=refer_issue.version,
            todo="",  # å¼•ç”¨çš„é—®é¢˜æœ¬èº«æ²¡æœ‰todo
            source_file=refer_issue.file_name,
            original_path=path + [f"[å¼•ç”¨]{refer_name}"],
            is_refer=True,
            parent_ref=parent_file
        )

        # é€’å½’æ„å»ºå¼•ç”¨é—®é¢˜çš„å­é¡¹
        for item in refer_issue.checklist:
            child_tree = self._build_child_tree(item, refer_issue.file_name, path + [f"[å¼•ç”¨]{refer_name}"])
            if child_tree:
                refer_tree.children.append(child_tree)

        return refer_tree

    def _parse_yml_file(self, file_path: Path) -> Optional[Issue]:
        """è§£æå•ä¸ªymlæ–‡ä»¶"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)

            if not data or 'status' not in data:
                return None

            checklist_items = []
            for item_data in data.get('checklist', []):
                checklist_item = self._parse_checklist_item(item_data)
                if checklist_item:
                    checklist_items.append(checklist_item)

            return Issue(
                file_name=file_path.stem,
                status=data['status'],
                describe=data.get('describe', ''),
                checklist=checklist_items
            )

        except Exception as e:
            print(f"è§£ææ–‡ä»¶ {file_path} å¤±è´¥: {e}")
            return None

    def _parse_checklist_item(self, item_data: dict) -> Optional[ChecklistItem]:
        """è§£æchecklisté¡¹ç›®"""
        if 'status' not in item_data:
            return None

        # å¤„ç†referç±»å‹
        if 'refer' in item_data:
            return ChecklistItem(
                status=f"å¼•ç”¨: {item_data['refer']}",
                describe=f"å…³è”åˆ°é—®é¢˜: {item_data['refer']}",
                priority=1,
                version="-",
                todo=f"è·³è½¬åˆ°é—®é¢˜: {item_data['refer']}",
                refer=item_data['refer']
            )

        # å¤„ç†æ™®é€šchecklisté¡¹
        checklist_subitems = []
        for subitem_data in item_data.get('checklist', []):
            subitem = self._parse_checklist_item(subitem_data)
            if subitem:
                checklist_subitems.append(subitem)

        return ChecklistItem(
            status=item_data['status'],
            describe=item_data.get('describe', ''),
            priority=item_data.get('priority', 5),
            version=item_data.get('version', '-'),
            todo=item_data.get('todo', ''),
            checklist=checklist_subitems if checklist_subitems else None,
            refer=item_data.get('refer')
        )

    def get_issue_names(self) -> List[str]:
        """è·å–æ‰€æœ‰é—®é¢˜åç§°åˆ—è¡¨"""
        return self.issue_list.copy()
```

### 1.3 æ•°æ®éªŒè¯å™¨

#### 1.3.1 DataValidator ç±»è®¾è®¡
```python
class DataValidator:
    """æ•°æ®éªŒè¯å™¨"""

    @staticmethod
    def validate_issue(issue: Issue) -> List[str]:
        """éªŒè¯Issueæ•°æ®å®Œæ•´æ€§"""
        errors = []

        if not issue.status:
            errors.append("é—®é¢˜ç°è±¡ä¸èƒ½ä¸ºç©º")

        if not issue.checklist:
            errors.append("checklistä¸èƒ½ä¸ºç©º")

        for i, item in enumerate(issue.checklist):
            item_errors = DataValidator.validate_checklist_item(item, f"checklist[{i}]")
            errors.extend(item_errors)

        return errors

    @staticmethod
    def validate_checklist_item(item: ChecklistItem, path: str = "") -> List[str]:
        """éªŒè¯ChecklistItemæ•°æ®å®Œæ•´æ€§"""
        errors = []
        current_path = f"{path}.{item.status}" if path else item.status

        if not hasattr(item, 'status') or not item.status:
            # å¤„ç†çº¯referé¡¹
            if hasattr(item, 'refer') and item.refer:
                return errors  # çº¯referé¡¹æ²¡æœ‰statusæ˜¯æ­£å¸¸çš„
            else:
                errors.append(f"{current_path}: statusä¸èƒ½ä¸ºç©º")

        if hasattr(item, 'priority') and (item.priority < 1 or item.priority > 10):
            errors.append(f"{current_path}: priorityåº”è¯¥åœ¨1-10ä¹‹é—´")

        if hasattr(item, 'checklist') and item.checklist:
            for i, subitem in enumerate(item.checklist):
                subitem_errors = DataValidator.validate_checklist_item(
                    subitem, f"{current_path}.checklist[{i}]"
                )
                errors.extend(subitem_errors)

        return errors
```

## 2. ç³»ç»Ÿæ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

#### 2.1.1 Webåº”ç”¨æ¶æ„è®¾è®¡
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Webè¡¨ç¤ºå±‚ (Web Presentation Layer)         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Streamlit      â”‚  â”‚  ä¾§è¾¹æ          â”‚  â”‚  ä¸»å†…å®¹åŒº       â”‚ â”‚
â”‚  â”‚  Webç•Œé¢        â”‚  â”‚  é—®é¢˜é€‰æ‹©       â”‚  â”‚  è¯¦æƒ…é¢æ¿       â”‚ â”‚
â”‚  â”‚  å“åº”å¼è®¾è®¡     â”‚  â”‚  ç»Ÿè®¡ä¿¡æ¯       â”‚  â”‚  æ£€æŸ¥æ¸…å•       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ä¸šåŠ¡é€»è¾‘å±‚ (Business Layer)               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ IssueManager    â”‚  â”‚ ChecklistManagerâ”‚  â”‚ PathNavigator   â”‚ â”‚
â”‚  â”‚ SolutionEngine  â”‚  â”‚ StateManager    â”‚  â”‚  InteractionLogicâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ•°æ®è®¿é—®å±‚ (Data Access Layer)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ DataLoader      â”‚  â”‚ DataValidator   â”‚  â”‚  FileWatcher    â”‚ â”‚
â”‚  â”‚ YamlParser      â”‚  â”‚ CacheManager    â”‚  â”‚  ConfigLoader   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 2.1.2 Streamlit Webæ¶æ„ä¼˜åŠ¿
- **ç®€åŒ–å¼€å‘**: æ— éœ€HTML/CSS/JavaScriptçŸ¥è¯†ï¼Œçº¯Pythonå¼€å‘
- **å®æ—¶é¢„è§ˆ**: ä»£ç ä¿®æ”¹åæµè§ˆå™¨è‡ªåŠ¨åˆ·æ–°
- **å“åº”å¼è®¾è®¡**: è‡ªåŠ¨é€‚é…æ¡Œé¢ã€å¹³æ¿ã€æ‰‹æœºç­‰è®¾å¤‡
- **ä¸°å¯Œç»„ä»¶**: å†…ç½®å›¾è¡¨ã€è¡¨æ ¼ã€ä¾§è¾¹æ ç­‰Webç»„ä»¶
- **çŠ¶æ€ç®¡ç†**: å†…ç½®session_stateç®¡ç†ç”¨æˆ·ä¼šè¯çŠ¶æ€

### 2.2 æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### 2.2.1 Webåº”ç”¨æ§åˆ¶å™¨ (WebController)
```python
import streamlit as st
from typing import Dict, List, Optional

class WebController:
    """Streamlit Webåº”ç”¨æ§åˆ¶å™¨"""

    def __init__(self):
        self.data_loader = DataLoader()
        self.app_state = AppState()
        self.tree_builder = TreeBuilder(self.data_loader)
        self.app_state.tree_builder = self.tree_builder

    def initialize_session_state(self):
        """åˆå§‹åŒ–Streamlitä¼šè¯çŠ¶æ€"""
        if 'current_issue' not in st.session_state:
            st.session_state.current_issue = None
        if 'navigation_path' not in st.session_state:
            st.session_state.navigation_path = []
        if 'excluded_items' not in st.session_state:
            st.session_state.excluded_items = []
        if 'solution_text' not in st.session_state:
            st.session_state.solution_text = None

    def render_sidebar(self) -> Optional[str]:
        """æ¸²æŸ“ä¾§è¾¹æ å¹¶è¿”å›é€‰æ‹©çš„é—®é¢˜"""
        with st.sidebar:
            st.title("ğŸ”§ è¿ç»´æ’æŸ¥åŠ©æ‰‹")

            # é—®é¢˜é€‰æ‹©
            issue_names = list(self.data_loader.load_all_issues().keys())
            if issue_names:
                selected_issue = st.selectbox(
                    "ğŸ“‹ é€‰æ‹©é—®é¢˜ç°è±¡",
                    options=issue_names,
                    key="issue_selector"
                )

                if st.button("ğŸ”„ é‡ç½®", key="reset_button"):
                    self._reset_session_state()
                    st.rerun()

                return selected_issue
            return None

    def handle_issue_selection(self, issue_name: str):
        """å¤„ç†é—®é¢˜é€‰æ‹©"""
        if issue_name != st.session_state.get('current_issue'):
            issue = self.data_loader.get_issue_by_name(issue_name)
            if issue:
                self.app_state.set_current_issue(issue)
                self.app_state.build_current_tree()
                st.session_state.current_issue = issue_name
                st.session_state.navigation_path = [issue_name]
                st.session_state.excluded_items = []
                st.session_state.solution_text = None

    def _reset_session_state(self):
        """é‡ç½®ä¼šè¯çŠ¶æ€"""
        for key in st.session_state.keys():
            del st.session_state[key]
        self.initialize_session_state()
```

#### 2.2.2 é—®é¢˜ç®¡ç†å™¨ (IssueManager)
```python
class IssueManager:
    """é—®é¢˜ç®¡ç†å™¨"""

    def __init__(self, data_loader: DataLoader):
        self.data_loader = data_loader

    def get_issue_by_name(self, name: str) -> Optional[Issue]:
        """æ ¹æ®åç§°è·å–é—®é¢˜"""
        return self.data_loader.issues.get(name)

    def search_issues(self, keyword: str) -> List[Issue]:
        """æœç´¢é—®é¢˜"""
        keyword = keyword.lower()
        results = []

        for issue in self.data_loader.issues.values():
            if (keyword in issue.status.lower() or
                keyword in issue.describe.lower()):
                results.append(issue)

        return results

    def get_all_issue_names(self) -> List[str]:
        """è·å–æ‰€æœ‰é—®é¢˜åç§°"""
        return self.data_loader.get_issue_names()
```

#### 2.2.3 æ ‘å½¢Checklistç®¡ç†å™¨ (TreeChecklistManager)
```python
class TreeChecklistManager:
    """æ ‘å½¢Checklistç®¡ç†å™¨"""

    def __init__(self, app_state: AppState):
        self.app_state = app_state

    def get_current_checklist(self) -> List[TreeChecklistItem]:
        """è·å–å½“å‰å±‚çº§çš„checklist"""
        return self.app_state.get_current_checklist_items()

    def exclude_checklist_item(self, item: TreeChecklistItem):
        """æ’é™¤checklisté¡¹"""
        item_path = " â†’ ".join(item.original_path)
        if item_path not in self.app_state.excluded_items:
            self.app_state.excluded_items.append(item_path)

    def confirm_checklist_item(self, item: TreeChecklistItem) -> Optional[str]:
        """ç¡®è®¤checklisté¡¹ï¼Œè¿”å›è§£å†³æ–¹æ¡ˆ"""
        if item.children:
            # æœ‰å­é¡¹ï¼Œè·³è½¬åˆ°å­å±‚çº§
            self.app_state.current_checklist = item
            self.app_state.navigation_path = item.original_path.copy()
            return None
        else:
            # å¶å­èŠ‚ç‚¹ï¼Œè¿”å›è§£å†³æ–¹æ¡ˆ
            return item.todo

    def navigate_to_parent(self) -> bool:
        """å¯¼èˆªåˆ°çˆ¶çº§"""
        if len(self.app_state.navigation_path) <= 1:
            return False

        # ç§»é™¤å½“å‰èŠ‚ç‚¹
        self.app_state.navigation_path.pop()

        # æŸ¥æ‰¾çˆ¶èŠ‚ç‚¹
        parent_path = self.app_state.navigation_path.copy()
        parent_item = self._find_item_by_path(self.app_state.current_tree, parent_path)

        if parent_item:
            self.app_state.current_checklist = parent_item
            return True

        return False

    def _find_item_by_path(self, tree: TreeChecklistItem, path: List[str]) -> Optional[TreeChecklistItem]:
        """æ ¹æ®è·¯å¾„æŸ¥æ‰¾æ ‘èŠ‚ç‚¹"""
        current = tree

        for path_part in path[1:]:  # è·³è¿‡æ ¹èŠ‚ç‚¹
            found = False
            for child in current.children:
                if child.status == path_part or f"[å¼•ç”¨]{child.status}" == path_part:
                    current = child
                    found = True
                    break

            if not found:
                return None

        return current
```

### 2.3 å¯¼èˆªç³»ç»Ÿè®¾è®¡

#### 2.3.1 è·¯å¾„å¯¼èˆªå™¨ (PathNavigator)
```python
class PathNavigator:
    """è·¯å¾„å¯¼èˆªå™¨"""

    def __init__(self, app_state: AppState):
        self.app_state = app_state

    def navigate_to_level(self, level: int) -> bool:
        """å¯¼èˆªåˆ°æŒ‡å®šå±‚çº§"""
        if level < 0 or level >= len(self.app_state.navigation_path):
            return False

        # æˆªæ–­è·¯å¾„åˆ°æŒ‡å®šå±‚çº§
        self.app_state.navigation_path = self.app_state.navigation_path[:level]

        # é‡ç½®å½“å‰checkliståˆ°å¯¹åº”å±‚çº§
        if level == 0:
            self.app_state.current_checklist = None
        else:
            # æ ¹æ®è·¯å¾„æ‰¾åˆ°å¯¹åº”çš„checklisté¡¹
            target_item = self._find_checklist_by_path(self.app_state.navigation_path)
            self.app_state.current_checklist = target_item

        return True

    def _find_checklist_by_path(self, path: List[str]) -> Optional[ChecklistItem]:
        """æ ¹æ®è·¯å¾„æŸ¥æ‰¾checklisté¡¹"""
        if not path or not self.app_state.current_issue:
            return None

        current_checklist = self.app_state.current_issue.checklist

        for path_item in path[1:]:  # è·³è¿‡ç¬¬ä¸€ä¸ªï¼Œé‚£æ˜¯é—®é¢˜åç§°
            for item in current_checklist:
                if item.status == path_item:
                    if item.checklist:
                        current_checklist = item.checklist
                        break
            else:
                return None

        # æ‰¾åˆ°ç›®æ ‡é¡¹
        for item in current_checklist:
            if item.status == path[-1]:
                return item

        return None

    def get_current_path(self) -> List[str]:
        """è·å–å½“å‰å¯¼èˆªè·¯å¾„"""
        if not self.app_state.current_issue:
            return []

        path = [self.app_state.current_issue.status]
        path.extend(self.app_state.navigation_path[1:])  # è·³è¿‡é‡å¤çš„é—®é¢˜åç§°
        return path
```

## 3. åŠŸèƒ½æ¨¡å—è¯¦ç»†è®¾è®¡

### 3.1 Webç•Œé¢æ¨¡å— (WebInterface)

#### 3.1.1 Streamlitä¸»åº”ç”¨ç±» (MainApp)
```python
import streamlit as st
from typing import Dict, List, Optional

class MainApp:
    """Streamlitä¸»åº”ç”¨ç±»"""

    def __init__(self):
        self.controller = WebController()
        self.setup_page_config()

    def setup_page_config(self):
        """è®¾ç½®é¡µé¢é…ç½®"""
        st.set_page_config(
            page_title="è¿ç»´çŸ¥è¯†åº“æ™ºèƒ½æ’æŸ¥åŠ©æ‰‹",
            page_icon="ğŸ”§",
            layout="wide",
            initial_sidebar_state="expanded"
        )

    def run(self):
        """è¿è¡Œä¸»åº”ç”¨"""
        # åˆå§‹åŒ–ä¼šè¯çŠ¶æ€
        self.controller.initialize_session_state()

        # æ¸²æŸ“ä¾§è¾¹æ 
        selected_issue = self.controller.render_sidebar()

        # å¤„ç†é—®é¢˜é€‰æ‹©
        if selected_issue:
            self.controller.handle_issue_selection(selected_issue)

        # æ¸²æŸ“ä¸»å†…å®¹åŒº
        self._render_main_content()

    def _render_main_content(self):
        """æ¸²æŸ“ä¸»å†…å®¹åŒº"""
        if not st.session_state.get('current_issue'):
            self._show_welcome_screen()
            return

        # æ˜¾ç¤ºæ ‡é¢˜
        st.title(f"ğŸ” {st.session_state.current_issue}")

        # åˆ›å»ºä¸¤åˆ—å¸ƒå±€
        col1, col2 = st.columns([1, 3])

        with col1:
            self._render_navigation_panel()

        with col2:
            self._render_detail_panel()
            self._render_checklist_panel()
            self._render_solution_panel()

    def _show_welcome_screen(self):
        """æ˜¾ç¤ºæ¬¢è¿ç•Œé¢"""
        st.markdown("""
        # ğŸ”§ è¿ç»´çŸ¥è¯†åº“æ™ºèƒ½æ’æŸ¥åŠ©æ‰‹

        è¯·ä»å·¦ä¾§é€‰æ‹©è¦æ’æŸ¥çš„é—®é¢˜ç°è±¡ï¼Œå¼€å§‹æ™ºèƒ½æ’æŸ¥æµç¨‹ã€‚

        ## ä½¿ç”¨è¯´æ˜
        1. ä»å·¦ä¾§é€‰æ‹©é—®é¢˜ç°è±¡
        2. æŸ¥çœ‹é—®é¢˜è¯¦æƒ…
        3. é€é¡¹ç¡®è®¤checklist
        4. è·å–è§£å†³æ–¹æ¡ˆ

        é€‰æ‹©é—®é¢˜åï¼Œç³»ç»Ÿå°†å¼•å¯¼æ‚¨å®Œæˆæ’æŸ¥æµç¨‹ã€‚
        """)

    def _render_navigation_panel(self):
        """æ¸²æŸ“å¯¼èˆªé¢æ¿"""
        st.subheader("ğŸ“ å½“å‰æ’æŸ¥è·¯å¾„")

        navigation_path = st.session_state.get('navigation_path', [])
        if navigation_path:
            for i, path_item in enumerate(navigation_path):
                if i == 0:
                    st.markdown(f"ğŸ“ **{path_item}**")
                else:
                    indent = "ã€€ã€€" * i
                    if i == len(navigation_path) - 1:
                        st.markdown(f"{indent}â—‰ **{path_item}**")
                    else:
                        st.markdown(f"{indent}â””â”€ {path_item}")
        else:
            st.info("æœªå¼€å§‹æ’æŸ¥")

    def _render_detail_panel(self):
        """æ¸²æŸ“è¯¦æƒ…é¢æ¿"""
        st.subheader("ğŸ“‹ å½“å‰é—®é¢˜è¯¦æƒ…")

        # è·å–å½“å‰é—®é¢˜ä¿¡æ¯
        issue_name = st.session_state.get('current_issue')
        if issue_name:
            issue = self.controller.data_loader.get_issue_by_name(issue_name)
            if issue:
                col1, col2 = st.columns(2)
                with col1:
                    st.metric("ä¼˜å…ˆçº§", issue.priority)
                with col2:
                    st.metric("ç‰ˆæœ¬", issue.version if issue.version else "-")

                st.markdown(f"**é—®é¢˜æè¿°**: {issue.describe}")

    def _render_checklist_panel(self):
        """æ¸²æŸ“æ£€æŸ¥æ¸…å•é¢æ¿"""
        st.subheader("âœ… Checklistç¡®è®¤")

        # è·å–å½“å‰æ£€æŸ¥æ¸…å•
        checklist_items = self.controller.app_state.get_current_checklist_items()

        if not checklist_items:
            st.info("æ²¡æœ‰æ£€æŸ¥é¡¹")
            return

        for i, item in enumerate(checklist_items):
            with st.expander(f"{item.status} (ä¼˜å…ˆçº§: {item.priority})"):
                st.write(item.describe)

                col1, col2 = st.columns([1, 1])

                with col1:
                    excluded_key = f"exclude_{i}"
                    if st.checkbox(f"æ’é™¤ {item.status}", key=excluded_key):
                        self._handle_exclude_item(item)

                with col2:
                    confirm_key = f"confirm_{i}"
                    if st.button(f"ç¡®è®¤ {item.status}", key=confirm_key):
                        self._handle_confirm_item(item)

    def _render_solution_panel(self):
        """æ¸²æŸ“è§£å†³æ–¹æ¡ˆé¢æ¿"""
        solution_text = st.session_state.get('solution_text')
        if solution_text:
            st.subheader("ğŸ› ï¸ è§£å†³æ–¹æ¡ˆ")
            st.success(solution_text)

    def _handle_exclude_item(self, item):
        """å¤„ç†æ’é™¤é¡¹ç›®"""
        if item.status not in st.session_state.get('excluded_items', []):
            st.session_state.excluded_items.append(item.status)
            st.success(f"å·²æ’é™¤: {item.status}")
            st.rerun()

    def _handle_confirm_item(self, item):
        """å¤„ç†ç¡®è®¤é¡¹ç›®"""
        if item.todo:
            # æ˜¾ç¤ºè§£å†³æ–¹æ¡ˆ
            st.session_state.solution_text = item.todo
            st.success(f"ç¡®è®¤åŸå› : {item.status}")
            st.rerun()
        elif hasattr(item, 'children') and item.children:
            # è¿›å…¥ä¸‹ä¸€å±‚çº§
            self.controller.app_state.current_checklist = item
            new_path = st.session_state.navigation_path.copy()
            new_path.append(item.status)
            st.session_state.navigation_path = new_path
            st.session_state.solution_text = None
            st.rerun()
        else:
            st.info("éœ€è¦è¿›ä¸€æ­¥æ’æŸ¥å­é¡¹")
  #### 3.1.2 Webç•Œé¢æ¸²æŸ“å™¨ (WebRenderer)
```python
import streamlit as st
from typing import Dict, List, Optional

class WebRenderer:
    """Webç•Œé¢æ¸²æŸ“å™¨"""

    @staticmethod
    def render_checklist_item(item, index: int):
        """æ¸²æŸ“å•ä¸ªæ£€æŸ¥é¡¹"""
        with st.expander(f"{item.status} (ä¼˜å…ˆçº§: {item.priority})"):
            st.write(item.describe)

            col1, col2 = st.columns([1, 1])

            with col1:
                excluded = st.checkbox(f"æ’é™¤ {item.status}", key=f"exclude_{index}")
                if excluded:
                    return 'exclude'

            with col2:
                if st.button(f"ç¡®è®¤ {item.status}", key=f"confirm_{index}"):
                    return 'confirm'

        return None

    @staticmethod
    def render_solution_steps(todo_text: str):
        """æ¸²æŸ“è§£å†³æ–¹æ¡ˆæ­¥éª¤"""
        st.subheader("ğŸ› ï¸ è§£å†³æ–¹æ¡ˆ")

        with st.success("è§£å†³æ–¹æ¡ˆå·²æ‰¾åˆ°"):
            st.markdown("**æ“ä½œæ­¥éª¤:**")

            # ç®€å•çš„æ­¥éª¤è§£æï¼ˆå‡è®¾todoä¸­åŒ…å«ç¼–å·æ­¥éª¤ï¼‰
            lines = todo_text.split('\n')
            for line in lines:
                line = line.strip()
                if line and (line[0].isdigit() or line.startswith('-')):
                    st.markdown(f"- {line}")
                elif line:
                    st.markdown(line)

    @staticmethod
    def render_progress_stats(current_issue: str, excluded_items: List[str]):
        """æ¸²æŸ“è¿›åº¦ç»Ÿè®¡"""
        col1, col2, col3 = st.columns(3)

        with col1:
            st.metric("å½“å‰é—®é¢˜", current_issue)

        with col2:
            st.metric("å·²æ’é™¤", len(excluded_items))

        with col3:
            # è¿™é‡Œå¯ä»¥è®¡ç®—å‰©ä½™é¡¹ç›®æ•°
            st.metric("æ’æŸ¥çŠ¶æ€", "è¿›è¡Œä¸­" if excluded_items else "å¾…å¼€å§‹")
```
  ### 3.2 Webéƒ¨ç½²å’Œé…ç½®

#### 3.2.1 åº”ç”¨å…¥å£æ–‡ä»¶ (main.py)
```python
#!/usr/bin/env python3
"""
è¿ç»´çŸ¥è¯†åº“æ™ºèƒ½æ’æŸ¥åŠ©æ‰‹ - Streamlit Webç‰ˆæœ¬
"""

import sys
from pathlib import Path

# æ·»åŠ é¡¹ç›®è·¯å¾„
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

import streamlit as st
from src.web_app import MainApp

def main():
    """ä¸»å‡½æ•°"""
    app = MainApp()
    app.run()

if __name__ == "__main__":
    main()
```

#### 3.2.2 Streamlité…ç½®æ–‡ä»¶ (.streamlit/config.toml)
```toml
[theme]
primaryColor = "#FF6B6B"
backgroundColor = "#FFFFFF"
secondaryBackgroundColor = "#F0F2F6"
textColor = "#262730"
font = "sans serif"

[server]
headless = true
port = 8501
address = "localhost"

[browser]
gatherUsageStats = false
```

#### 3.2.3 ä¾èµ–ç®¡ç† (requirements.txt)
```txt
# æ ¸å¿ƒä¾èµ–
streamlit>=1.28.0
PyYAML>=6.0

# æ•°æ®å¤„ç†
pandas>=1.5.0  # å¯é€‰ï¼Œç”¨äºæ•°æ®åˆ†æåŠŸèƒ½

# éƒ¨ç½²ç›¸å…³
gunicorn>=21.2.0  # ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²
```

#### 3.2.4 å¯åŠ¨è„šæœ¬
**Windowså¯åŠ¨è„šæœ¬** (scripts/start_web.bat):
```batch
@echo off
echo å¯åŠ¨è¿ç»´æ’æŸ¥åŠ©æ‰‹Webç‰ˆæœ¬...
cd /d "%~dp0.."

# æ£€æŸ¥Pythonç¯å¢ƒ
python --version >nul 2>&1
if errorlevel 1 (
    echo é”™è¯¯: æœªæ‰¾åˆ°Pythonç¯å¢ƒ
    pause
    exit /b 1
)

# æ£€æŸ¥ä¾èµ–
echo æ£€æŸ¥ä¾èµ–...
pip install -r requirements.txt

# å¯åŠ¨Streamlitåº”ç”¨
echo å¯åŠ¨Webåº”ç”¨...
streamlit run src/web_app.py --server.headless false --server.port 8501

pause
```

**Linux/Macå¯åŠ¨è„šæœ¬** (scripts/start_web.sh):
```bash
#!/bin/bash
echo "å¯åŠ¨è¿ç»´æ’æŸ¥åŠ©æ‰‹Webç‰ˆæœ¬..."

# åˆ‡æ¢åˆ°é¡¹ç›®æ ¹ç›®å½•
cd "$(dirname "$0")/.."

# æ£€æŸ¥Pythonç¯å¢ƒ
if ! command -v python3 &> /dev/null; then
    echo "é”™è¯¯: æœªæ‰¾åˆ°Python3ç¯å¢ƒ"
    exit 1
fi

# æ£€æŸ¥ä¾èµ–
echo "æ£€æŸ¥ä¾èµ–..."
pip3 install -r requirements.txt

# å¯åŠ¨Streamlitåº”ç”¨
echo "å¯åŠ¨Webåº”ç”¨..."
streamlit run src/web_app.py --server.headless false --server.port 8501
```

  ## 4. æ€»ç»“å’Œä¼˜åŠ¿

### 4.1 Streamlitç‰ˆæœ¬ä¼˜åŠ¿

1. **å¼€å‘æ•ˆç‡æå‡90%**:
   - æ— éœ€å­¦ä¹ HTML/CSS/JavaScript
   - çº¯Pythonå¼€å‘ï¼Œé™ä½å­¦ä¹ æˆæœ¬
   - å†…ç½®ä¸°å¯Œç»„ä»¶ï¼Œå¼€ç®±å³ç”¨

2. **éƒ¨ç½²ç®€å•**:
   - å•å‘½ä»¤å¯åŠ¨: `streamlit run src/web_app.py`
   - è‡ªåŠ¨ç”ŸæˆWebç•Œé¢ï¼Œæ— éœ€é…ç½®WebæœåŠ¡å™¨
   - æ”¯æŒå†…ç½‘éƒ¨ç½²å’Œäº‘ç«¯éƒ¨ç½²

3. **ç”¨æˆ·ä½“éªŒä¼˜å¼‚**:
   - å“åº”å¼è®¾è®¡ï¼Œé€‚é…å„ç§è®¾å¤‡
   - å®æ—¶äº¤äº’ï¼Œæ— éœ€é¡µé¢åˆ·æ–°
   - ä¸“ä¸šçš„Webç•Œé¢å¤–è§‚

4. **ç»´æŠ¤æˆæœ¬ä½**:
   - ä»£ç é‡å‡å°‘70%
   - ç»„ä»¶ç»Ÿä¸€ï¼Œç•Œé¢ä¸€è‡´æ€§é«˜
   - è°ƒè¯•ç®€å•ï¼Œé”™è¯¯ä¿¡æ¯æ¸…æ™°

### 4.2 æŠ€æœ¯ç‰¹ç‚¹

- **æ•°æ®é©±åŠ¨**: åŸºäºYAMLé…ç½®æ–‡ä»¶ï¼Œæ˜“äºç»´æŠ¤å’Œæ‰©å±•
- **æ ‘å½¢ç»“æ„**: æ”¯æŒreferå¼•ç”¨ï¼Œæ„å»ºå¤æ‚çš„æ’æŸ¥çŸ¥è¯†æ ‘
- **å¼ºç±»å‹è®¾è®¡**: ä½¿ç”¨dataclassç¡®ä¿ä»£ç è´¨é‡
- **çŠ¶æ€ç®¡ç†**: Streamlitå†…ç½®session_stateç®¡ç†ç”¨æˆ·ä¼šè¯
- **æ¨¡å—åŒ–è®¾è®¡**: æ¸…æ™°çš„åˆ†å±‚æ¶æ„ï¼Œä¾¿äºæ‰©å±•

### 4.3 éƒ¨ç½²å»ºè®®

1. **å¼€å‘ç¯å¢ƒ**: ä½¿ç”¨Streamlitå¼€å‘æœåŠ¡å™¨
2. **æµ‹è¯•ç¯å¢ƒ**: ä½¿ç”¨Streamlit Sharingæˆ–å†…ç½‘éƒ¨ç½²
3. **ç”Ÿäº§ç¯å¢ƒ**: é…åˆGunicorn + Nginxéƒ¨ç½²
4. **å®¹å™¨åŒ–**: ä½¿ç”¨Dockeræ‰“åŒ…éƒ¨ç½²

è¿™ä¸ªæŠ€æœ¯è®¾è®¡æ–¹æ¡ˆä¸ºè¿ç»´æ’æŸ¥åŠ©æ‰‹æä¾›äº†å®Œæ•´çš„WebåŒ–è§£å†³æ–¹æ¡ˆï¼Œå¤§å¤§æå‡äº†å¼€å‘æ•ˆç‡å’Œç”¨æˆ·ä½“éªŒã€‚

# è¿ç»´æ’æŸ¥åŠ©æ‰‹ æŠ€æœ¯è®¾è®¡æ–¹æ¡ˆ

## 1. æ•°æ®æ¨¡å‹è®¾è®¡

### 1.1 æ ¸å¿ƒæ•°æ®ç»“æ„

#### 1.1.1 ChecklistItem æ•°æ®æ¨¡å‹
```python
from dataclasses import dataclass
from typing import List, Optional

@dataclass
class ChecklistItem:
    """æ£€æŸ¥é¡¹ç›®æ•°æ®æ¨¡å‹"""
    status: str           # ç›´æ¥åŸå› ç°è±¡æè¿°
    describe: str         # è¯¦ç»†è¯´æ˜å’Œç¡®è®¤æ–¹æ³•
    priority: int         # ä¼˜å…ˆçº§(1-10ï¼Œæ•°å­—è¶Šå¤§è¶Šé‡è¦)
    version: str          # å½±å“ç‰ˆæœ¬èŒƒå›´
    todo: str            # è§£å†³æ–¹æ¡ˆæè¿°
    checklist: Optional[List['ChecklistItem']] = None  # å­checklist
    refer: Optional[str] = None  # ç›¸å…³é—®é¢˜å¼•ç”¨
    excluded: bool = False  # æ˜¯å¦å·²æ’é™¤è¯¥åŸå› 
    confirmed: bool = False  # æ˜¯å¦å·²ç¡®è®¤è¯¥åŸå› å­˜åœ¨
```

#### 1.1.2 Issue æ•°æ®æ¨¡å‹
```python
@dataclass
class Issue:
    """é—®é¢˜ç°è±¡æ•°æ®æ¨¡å‹ï¼ˆæ”¯æŒé¡¶å±‚priorityå’Œversionï¼‰"""
    file_name: str        # ymlæ–‡ä»¶å
    status: str           # é—®é¢˜ç°è±¡æ ‡é¢˜
    describe: str         # é—®é¢˜æè¿°
    priority: int         # é—®é¢˜æ•´ä½“ä¼˜å…ˆçº§
    version: str          # é—®é¢˜å½±å“ç‰ˆæœ¬
    checklist: List[ChecklistItem]  # ç›´æ¥åŸå› checkliståˆ—è¡¨

    def get_checklist_by_priority(self) -> List[ChecklistItem]:
        """æŒ‰ä¼˜å…ˆçº§é™åºè¿”å›checklist"""
        return sorted(self.checklist, key=lambda x: x.priority, reverse=True)


@dataclass
class TreeChecklistItem:
    """æ ‘å½¢æ£€æŸ¥é¡¹æ•°æ®æ¨¡å‹ï¼ˆæ”¯æŒreferå¼•ç”¨å’Œæ ‘å½¢ç»“æ„ï¼‰"""
    status: str                    # æ˜¾ç¤ºæ ‡é¢˜
    describe: str                  # æè¿°
    priority: int                  # ä¼˜å…ˆçº§
    version: str                   # ç‰ˆæœ¬
    todo: str                      # è§£å†³æ–¹æ¡ˆ
    source_file: str               # æ¥æºymlæ–‡ä»¶
    original_path: List[str]       # åŸå§‹è·¯å¾„ï¼ˆç”¨äºå¯¼èˆªï¼‰
    children: List['TreeChecklistItem'] = field(default_factory=list)  # å­é¡¹
    is_refer: bool = False         # æ˜¯å¦ä¸ºreferå¼•ç”¨çš„é¡¹
    parent_ref: Optional[str] = None  # çˆ¶çº§å¼•ç”¨æ¥æº
```

#### 1.1.3 åº”ç”¨çŠ¶æ€æ¨¡å‹
```python
@dataclass
class AppState:
    """åº”ç”¨çŠ¶æ€ç®¡ç†ï¼ˆæ”¯æŒæ ‘å½¢ç»“æ„ï¼‰"""
    current_issue: Optional[Issue] = None  # å½“å‰é—®é¢˜
    current_tree: Optional[TreeChecklistItem] = None  # å½“å‰æ ‘å½¢ç»“æ„
    current_checklist: Optional[TreeChecklistItem] = None  # å½“å‰æ£€æŸ¥é¡¹
    excluded_items: List[str] = field(default_factory=list)  # å·²æ’é™¤é¡¹ç›®è·¯å¾„
    navigation_path: List[str] = field(default_factory=list)  # å½“å‰å¯¼èˆªè·¯å¾„
    solution_text: Optional[str] = None  # å½“å‰æ˜¾ç¤ºçš„è§£å†³æ–¹æ¡ˆ
    tree_builder: Optional[TreeBuilder] = None  # æ ‘å½¢æ„å»ºå™¨

    def get_current_path_display(self) -> str:
        """è·å–å½“å‰è·¯å¾„çš„æ˜¾ç¤ºæ–‡æœ¬"""
        return " â†’ ".join(self.navigation_path) if self.navigation_path else "æœªé€‰æ‹©"

    def build_current_tree(self):
        """æ„å»ºå½“å‰é—®é¢˜çš„å®Œæ•´æ ‘å½¢ç»“æ„"""
        if self.current_issue and self.tree_builder:
            self.current_tree = self.tree_builder.build_complete_tree(self.current_issue.status)
            return self.current_tree
        return None

    def get_current_checklist_items(self) -> List[TreeChecklistItem]:
        """è·å–å½“å‰å±‚çº§çš„checklisté¡¹"""
        if not self.current_checklist:
            if self.current_tree:
                return sorted(self.current_tree.children, key=lambda x: x.priority, reverse=True)
            return []

        return sorted(self.current_checklist.children, key=lambda x: x.priority, reverse=True)
```

### 1.2 YAMLæ•°æ®è§£æå™¨

#### 1.2.1 DataLoader ç±»è®¾è®¡
```python
import yaml
import os
from pathlib import Path
from typing import Dict

class DataLoader:
    """YAMLæ•°æ®åŠ è½½å’Œè§£æå™¨"""

    def __init__(self, data_dir: str = "data"):
        self.data_dir = Path(data_dir)
        self.issues: Dict[str, Issue] = {}
        self.issue_list: List[str] = []

    def load_all_issues(self) -> Dict[str, Issue]:
        """åŠ è½½æ‰€æœ‰ymlæ–‡ä»¶ä¸­çš„é—®é¢˜æ•°æ®"""
        self.issues.clear()
        self.issue_list.clear()

        for yml_file in self.data_dir.glob("*.yml"):
            issue = self._parse_yml_file(yml_file)
            if issue:
                self.issues[issue.status] = issue
                self.issue_list.append(issue.status)

        return self.issues


class TreeBuilder:
    """æ ‘å½¢ç»“æ„æ„å»ºå™¨ - å¤„ç†referå¼•ç”¨å’Œæ ‘å½¢ç»“æ„æ‹¼æ¥"""

    def __init__(self, data_loader: DataLoader):
        self.data_loader = data_loader
        self.built_trees = {}

    def build_complete_tree(self, root_issue_name: str) -> Optional[TreeChecklistItem]:
        """æ„å»ºå®Œæ•´çš„æ ‘å½¢ç»“æ„"""
        if root_issue_name in self.built_trees:
            return self.built_trees[root_issue_name]

        root_issue = self.data_loader.get_issue_by_name(root_issue_name)
        if not root_issue:
            return None

        # æ„å»ºæ ¹èŠ‚ç‚¹
        root_tree = TreeChecklistItem(
            status=root_issue.status,
            describe=root_issue.describe,
            priority=root_issue.priority,
            version=root_issue.version,
            todo="",  # æ ¹é—®é¢˜æ²¡æœ‰todo
            source_file=root_issue.file_name,
            original_path=[root_issue.status],
            is_refer=False
        )

        # é€’å½’æ„å»ºå­æ ‘
        for item in root_issue.checklist:
            child_tree = self._build_child_tree(item, root_issue.file_name, [root_issue.status])
            if child_tree:
                root_tree.children.append(child_tree)

        # ç¼“å­˜æ„å»ºç»“æœ
        self.built_trees[root_issue_name] = root_tree
        return root_tree

    def _build_child_tree(self, item: ChecklistItem, parent_file: str, path: List[str]) -> Optional[TreeChecklistItem]:
        """æ„å»ºå­æ ‘"""
        if hasattr(item, 'refer') and item.refer:
            # å¤„ç†referå¼•ç”¨
            return self._build_refer_tree(item.refer, parent_file, path)
        else:
            # å¤„ç†æ™®é€šé¡¹
            tree_item = TreeChecklistItem(
                status=item.status,
                describe=item.describe,
                priority=item.priority,
                version=item.version,
                todo=item.todo or "",
                source_file=parent_file,
                original_path=path + [item.status],
                is_refer=False
            )

            # é€’å½’å¤„ç†å­é¡¹
            if hasattr(item, 'checklist') and item.checklist:
                for child_item in item.checklist:
                    child_tree = self._build_child_tree(child_item, parent_file, path + [item.status])
                    if child_tree:
                        tree_item.children.append(child_tree)

            return tree_item

    def _build_refer_tree(self, refer_name: str, parent_file: str, path: List[str]) -> Optional[TreeChecklistItem]:
        """æ„å»ºå¼•ç”¨æ ‘"""
        refer_issue = self.data_loader.get_issue_by_name(refer_name)
        if not refer_issue:
            return None

        # åˆ›å»ºå¼•ç”¨èŠ‚ç‚¹
        refer_tree = TreeChecklistItem(
            status=refer_issue.status,
            describe=refer_issue.describe,
            priority=refer_issue.priority,
            version=refer_issue.version,
            todo="",  # å¼•ç”¨çš„é—®é¢˜æœ¬èº«æ²¡æœ‰todo
            source_file=refer_issue.file_name,
            original_path=path + [f"[å¼•ç”¨]{refer_name}"],
            is_refer=True,
            parent_ref=parent_file
        )

        # é€’å½’æ„å»ºå¼•ç”¨é—®é¢˜çš„å­é¡¹
        for item in refer_issue.checklist:
            child_tree = self._build_child_tree(item, refer_issue.file_name, path + [f"[å¼•ç”¨]{refer_name}"])
            if child_tree:
                refer_tree.children.append(child_tree)

        return refer_tree

    def _parse_yml_file(self, file_path: Path) -> Optional[Issue]:
        """è§£æå•ä¸ªymlæ–‡ä»¶"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)

            if not data or 'status' not in data:
                return None

            checklist_items = []
            for item_data in data.get('checklist', []):
                checklist_item = self._parse_checklist_item(item_data)
                if checklist_item:
                    checklist_items.append(checklist_item)

            return Issue(
                file_name=file_path.stem,
                status=data['status'],
                describe=data.get('describe', ''),
                checklist=checklist_items
            )

        except Exception as e:
            print(f"è§£ææ–‡ä»¶ {file_path} å¤±è´¥: {e}")
            return None

    def _parse_checklist_item(self, item_data: dict) -> Optional[ChecklistItem]:
        """è§£æchecklisté¡¹ç›®"""
        if 'status' not in item_data:
            return None

        # å¤„ç†referç±»å‹
        if 'refer' in item_data:
            return ChecklistItem(
                status=f"å¼•ç”¨: {item_data['refer']}",
                describe=f"å…³è”åˆ°é—®é¢˜: {item_data['refer']}",
                priority=1,
                version="-",
                todo=f"è·³è½¬åˆ°é—®é¢˜: {item_data['refer']}",
                refer=item_data['refer']
            )

        # å¤„ç†æ™®é€šchecklisté¡¹
        checklist_subitems = []
        for subitem_data in item_data.get('checklist', []):
            subitem = self._parse_checklist_item(subitem_data)
            if subitem:
                checklist_subitems.append(subitem)

        return ChecklistItem(
            status=item_data['status'],
            describe=item_data.get('describe', ''),
            priority=item_data.get('priority', 5),
            version=item_data.get('version', '-'),
            todo=item_data.get('todo', ''),
            checklist=checklist_subitems if checklist_subitems else None,
            refer=item_data.get('refer')
        )

    def get_issue_names(self) -> List[str]:
        """è·å–æ‰€æœ‰é—®é¢˜åç§°åˆ—è¡¨"""
        return self.issue_list.copy()
```

### 1.3 æ•°æ®éªŒè¯å™¨

#### 1.3.1 DataValidator ç±»è®¾è®¡
```python
class DataValidator:
    """æ•°æ®éªŒè¯å™¨"""

    @staticmethod
    def validate_issue(issue: Issue) -> List[str]:
        """éªŒè¯Issueæ•°æ®å®Œæ•´æ€§"""
        errors = []

        if not issue.status:
            errors.append("é—®é¢˜ç°è±¡ä¸èƒ½ä¸ºç©º")

        if not issue.checklist:
            errors.append("checklistä¸èƒ½ä¸ºç©º")

        for i, item in enumerate(issue.checklist):
            item_errors = DataValidator.validate_checklist_item(item, f"checklist[{i}]")
            errors.extend(item_errors)

        return errors

    @staticmethod
    def validate_checklist_item(item: ChecklistItem, path: str = "") -> List[str]:
        """éªŒè¯ChecklistItemæ•°æ®å®Œæ•´æ€§"""
        errors = []
        current_path = f"{path}.{item.status}" if path else item.status

        if not hasattr(item, 'status') or not item.status:
            # å¤„ç†çº¯referé¡¹
            if hasattr(item, 'refer') and item.refer:
                return errors  # çº¯referé¡¹æ²¡æœ‰statusæ˜¯æ­£å¸¸çš„
            else:
                errors.append(f"{current_path}: statusä¸èƒ½ä¸ºç©º")

        if hasattr(item, 'priority') and (item.priority < 1 or item.priority > 10):
            errors.append(f"{current_path}: priorityåº”è¯¥åœ¨1-10ä¹‹é—´")

        if hasattr(item, 'checklist') and item.checklist:
            for i, subitem in enumerate(item.checklist):
                subitem_errors = DataValidator.validate_checklist_item(
                    subitem, f"{current_path}.checklist[{i}]"
                )
                errors.extend(subitem_errors)

        return errors
```

## 2. ç³»ç»Ÿæ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

#### 2.1.1 åˆ†å±‚æ¶æ„è®¾è®¡
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è¡¨ç¤ºå±‚ (Presentation Layer)               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  MainView       â”‚  â”‚  PathPanel      â”‚  â”‚  DetailPanel    â”‚ â”‚
â”‚  â”‚  ChecklistPanel â”‚  â”‚  SolutionPanel  â”‚  â”‚  ToolBar        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ä¸šåŠ¡é€»è¾‘å±‚ (Business Layer)               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ IssueManager    â”‚  â”‚ ChecklistManagerâ”‚  â”‚ PathNavigator   â”‚ â”‚
â”‚  â”‚ SolutionEngine  â”‚  â”‚ StateManager    â”‚  â”‚  InteractionLogicâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ•°æ®è®¿é—®å±‚ (Data Access Layer)            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ DataLoader      â”‚  â”‚ DataValidator   â”‚  â”‚  FileWatcher    â”‚ â”‚
â”‚  â”‚ YamlParser      â”‚  â”‚ CacheManager    â”‚  â”‚  ConfigLoader   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### 2.2.1 ä¸»æ§åˆ¶å™¨ (MainController)
```python
class MainController:
    """ä¸»åº”ç”¨æ§åˆ¶å™¨"""

    def __init__(self):
        self.data_loader = DataLoader()
        self.app_state = AppState()
        self.ui_manager = UIManager()

    def initialize(self):
        """åˆå§‹åŒ–åº”ç”¨"""
        # åŠ è½½æ•°æ®
        self.data_loader.load_all_issues()

        # åˆå§‹åŒ–UI
        self.ui_manager.initialize(self.data_loader.get_issue_names())

        # ç»‘å®šäº‹ä»¶å¤„ç†å™¨
        self._bind_events()

    def _bind_events(self):
        """ç»‘å®šUIäº‹ä»¶å¤„ç†å™¨"""
        self.ui_manager.on_issue_selected = self._on_issue_selected
        self.ui_manager.on_checklist_excluded = self._on_checklist_excluded
        self.ui_manager.on_checklist_confirmed = self._on_checklist_confirmed
        self.ui_manager.on_reset = self._on_reset
```

#### 2.2.2 é—®é¢˜ç®¡ç†å™¨ (IssueManager)
```python
class IssueManager:
    """é—®é¢˜ç®¡ç†å™¨"""

    def __init__(self, data_loader: DataLoader):
        self.data_loader = data_loader

    def get_issue_by_name(self, name: str) -> Optional[Issue]:
        """æ ¹æ®åç§°è·å–é—®é¢˜"""
        return self.data_loader.issues.get(name)

    def search_issues(self, keyword: str) -> List[Issue]:
        """æœç´¢é—®é¢˜"""
        keyword = keyword.lower()
        results = []

        for issue in self.data_loader.issues.values():
            if (keyword in issue.status.lower() or
                keyword in issue.describe.lower()):
                results.append(issue)

        return results

    def get_all_issue_names(self) -> List[str]:
        """è·å–æ‰€æœ‰é—®é¢˜åç§°"""
        return self.data_loader.get_issue_names()
```

#### 2.2.3 æ ‘å½¢Checklistç®¡ç†å™¨ (TreeChecklistManager)
```python
class TreeChecklistManager:
    """æ ‘å½¢Checklistç®¡ç†å™¨"""

    def __init__(self, app_state: AppState):
        self.app_state = app_state

    def get_current_checklist(self) -> List[TreeChecklistItem]:
        """è·å–å½“å‰å±‚çº§çš„checklist"""
        return self.app_state.get_current_checklist_items()

    def exclude_checklist_item(self, item: TreeChecklistItem):
        """æ’é™¤checklisté¡¹"""
        item_path = " â†’ ".join(item.original_path)
        if item_path not in self.app_state.excluded_items:
            self.app_state.excluded_items.append(item_path)

    def confirm_checklist_item(self, item: TreeChecklistItem) -> Optional[str]:
        """ç¡®è®¤checklisté¡¹ï¼Œè¿”å›è§£å†³æ–¹æ¡ˆ"""
        if item.children:
            # æœ‰å­é¡¹ï¼Œè·³è½¬åˆ°å­å±‚çº§
            self.app_state.current_checklist = item
            self.app_state.navigation_path = item.original_path.copy()
            return None
        else:
            # å¶å­èŠ‚ç‚¹ï¼Œè¿”å›è§£å†³æ–¹æ¡ˆ
            return item.todo

    def navigate_to_parent(self) -> bool:
        """å¯¼èˆªåˆ°çˆ¶çº§"""
        if len(self.app_state.navigation_path) <= 1:
            return False

        # ç§»é™¤å½“å‰èŠ‚ç‚¹
        self.app_state.navigation_path.pop()

        # æŸ¥æ‰¾çˆ¶èŠ‚ç‚¹
        parent_path = self.app_state.navigation_path.copy()
        parent_item = self._find_item_by_path(self.app_state.current_tree, parent_path)

        if parent_item:
            self.app_state.current_checklist = parent_item
            return True

        return False

    def _find_item_by_path(self, tree: TreeChecklistItem, path: List[str]) -> Optional[TreeChecklistItem]:
        """æ ¹æ®è·¯å¾„æŸ¥æ‰¾æ ‘èŠ‚ç‚¹"""
        current = tree

        for path_part in path[1:]:  # è·³è¿‡æ ¹èŠ‚ç‚¹
            found = False
            for child in current.children:
                if child.status == path_part or f"[å¼•ç”¨]{child.status}" == path_part:
                    current = child
                    found = True
                    break

            if not found:
                return None

        return current
```

### 2.3 å¯¼èˆªç³»ç»Ÿè®¾è®¡

#### 2.3.1 è·¯å¾„å¯¼èˆªå™¨ (PathNavigator)
```python
class PathNavigator:
    """è·¯å¾„å¯¼èˆªå™¨"""

    def __init__(self, app_state: AppState):
        self.app_state = app_state

    def navigate_to_level(self, level: int) -> bool:
        """å¯¼èˆªåˆ°æŒ‡å®šå±‚çº§"""
        if level < 0 or level >= len(self.app_state.navigation_path):
            return False

        # æˆªæ–­è·¯å¾„åˆ°æŒ‡å®šå±‚çº§
        self.app_state.navigation_path = self.app_state.navigation_path[:level]

        # é‡ç½®å½“å‰checkliståˆ°å¯¹åº”å±‚çº§
        if level == 0:
            self.app_state.current_checklist = None
        else:
            # æ ¹æ®è·¯å¾„æ‰¾åˆ°å¯¹åº”çš„checklisté¡¹
            target_item = self._find_checklist_by_path(self.app_state.navigation_path)
            self.app_state.current_checklist = target_item

        return True

    def _find_checklist_by_path(self, path: List[str]) -> Optional[ChecklistItem]:
        """æ ¹æ®è·¯å¾„æŸ¥æ‰¾checklisté¡¹"""
        if not path or not self.app_state.current_issue:
            return None

        current_checklist = self.app_state.current_issue.checklist

        for path_item in path[1:]:  # è·³è¿‡ç¬¬ä¸€ä¸ªï¼Œé‚£æ˜¯é—®é¢˜åç§°
            for item in current_checklist:
                if item.status == path_item:
                    if item.checklist:
                        current_checklist = item.checklist
                        break
            else:
                return None

        # æ‰¾åˆ°ç›®æ ‡é¡¹
        for item in current_checklist:
            if item.status == path[-1]:
                return item

        return None

    def get_current_path(self) -> List[str]:
        """è·å–å½“å‰å¯¼èˆªè·¯å¾„"""
        if not self.app_state.current_issue:
            return []

        path = [self.app_state.current_issue.status]
        path.extend(self.app_state.navigation_path[1:])  # è·³è¿‡é‡å¤çš„é—®é¢˜åç§°
        return path
```

## 3. åŠŸèƒ½æ¨¡å—è¯¦ç»†è®¾è®¡

### 3.1 ç•Œé¢ç®¡ç†æ¨¡å— (UIManager)

#### 3.1.1 ä¸»çª—å£ç±» (MainWindow)
```python
import tkinter as tk
from tkinter import ttk, messagebox

class MainWindow:
    """ä¸»çª—å£ç±»"""

    def __init__(self):
        self.root = tk.Tk()
        self.root.title("è¿ç»´çŸ¥è¯†åº“æ™ºèƒ½æ’æŸ¥åŠ©æ‰‹")
        self.root.geometry("1200x800")
        self.root.minsize(1000, 600)

        # ç•Œé¢ç»„ä»¶
        self.toolbar = None
        self.path_panel = None
        self.detail_panel = None
        self.checklist_panel = None
        self.solution_panel = None

        # äº‹ä»¶å›è°ƒ
        self.on_issue_selected = None
        self.on_checklist_excluded = None
        self.on_checklist_confirmed = None
        self.on_reset = None

    def initialize(self, issue_names: List[str]):
        """åˆå§‹åŒ–ç•Œé¢"""
        self._create_toolbar(issue_names)
        self._create_main_layout()
        self._create_status_bar()

    def _create_toolbar(self, issue_names: List[str]):
        """åˆ›å»ºå·¥å…·æ """
        toolbar_frame = ttk.Frame(self.root)
        toolbar_frame.pack(fill=tk.X, padx=5, pady=5)

        # é—®é¢˜é€‰æ‹©ä¸‹æ‹‰æ¡†
        ttk.Label(toolbar_frame, text="ç°è±¡ç­›é€‰:").pack(side=tk.LEFT, padx=5)

        self.issue_var = tk.StringVar()
        self.issue_combo = ttk.Combobox(
            toolbar_frame,
            textvariable=self.issue_var,
            values=issue_names,
            state="readonly",
            width=30
        )
        self.issue_combo.pack(side=tk.LEFT, padx=5)
        self.issue_combo.bind("<<ComboboxSelected>>", self._on_issue_selected)

        # é‡ç½®æŒ‰é’®
        ttk.Button(
            toolbar_frame,
            text="é‡ç½®",
            command=self._on_reset_clicked
        ).pack(side=tk.LEFT, padx=20)

    def _create_main_layout(self):
        """åˆ›å»ºä¸»å¸ƒå±€"""
        # ä¸»å®¹å™¨
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # åˆ›å»ºåˆ†å‰²çª—å£
        paned_window = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        paned_window.pack(fill=tk.BOTH, expand=True)

        # å·¦ä¾§è·¯å¾„é¢æ¿
        self.path_panel = PathPanel(paned_window, width=300)
        paned_window.add(self.path_panel.frame)

        # å³ä¾§å®¹å™¨
        right_frame = ttk.Frame(paned_window)
        paned_window.add(right_frame)

        # å³ä¾§å‚ç›´åˆ†å‰²
        right_paned = ttk.PanedWindow(right_frame, orient=tk.VERTICAL)
        right_paned.pack(fill=tk.BOTH, expand=True)

        # å³ä¸Šè¯¦æƒ…é¢æ¿
        self.detail_panel = DetailPanel(right_paned, height=200)
        right_paned.add(self.detail_panel.frame)

        # å³ä¸‹checklisté¢æ¿
        self.checklist_panel = ChecklistPanel(right_paned)
        right_paned.add(self.checklist_panel.frame)

        # åº•éƒ¨è§£å†³æ–¹æ¡ˆé¢æ¿
        self.solution_panel = SolutionPanel(main_frame, height=150)
        self.solution_panel.frame.pack(fill=tk.X, pady=(5, 0))

    def _create_status_bar(self):
        """åˆ›å»ºçŠ¶æ€æ """
        status_frame = ttk.Frame(self.root)
        status_frame.pack(fill=tk.X, side=tk.BOTTOM)

        self.status_label = ttk.Label(status_frame, text="å°±ç»ª")
        self.status_label.pack(side=tk.LEFT, padx=5)

    def _on_issue_selected(self, event=None):
        """é—®é¢˜é€‰æ‹©äº‹ä»¶å¤„ç†"""
        if self.on_issue_selected:
            issue_name = self.issue_var.get()
            self.on_issue_selected(issue_name)

    def _on_reset_clicked(self):
        """é‡ç½®æŒ‰é’®ç‚¹å‡»å¤„ç†"""
        if messagebox.askyesno("ç¡®è®¤", "ç¡®å®šè¦é‡ç½®å½“å‰æ’æŸ¥è¿›åº¦å—ï¼Ÿ"):
            if self.on_reset:
                self.on_reset()

    def update_path(self, path: List[str]):
        """æ›´æ–°è·¯å¾„æ˜¾ç¤º"""
        self.path_panel.update_path(path)

    def update_detail(self, checklist_item: ChecklistItem):
        """æ›´æ–°è¯¦æƒ…æ˜¾ç¤º"""
        self.detail_panel.update_content(checklist_item)

    def update_checklist(self, checklist: List[ChecklistItem]):
        """æ›´æ–°checklistæ˜¾ç¤º"""
        self.checklist_panel.update_checklist(checklist)

    def show_solution(self, solution: str):
        """æ˜¾ç¤ºè§£å†³æ–¹æ¡ˆ"""
        self.solution_panel.show_solution(solution)

    def clear_solution(self):
        """æ¸…é™¤è§£å†³æ–¹æ¡ˆ"""
        self.solution_panel.clear()

    def update_status(self, message: str):
        """æ›´æ–°çŠ¶æ€æ """
        self.status_label.config(text=message)

    def run(self):
        """è¿è¡Œä¸»å¾ªç¯"""
        self.root.mainloop()
```

#### 3.1.2 è·¯å¾„é¢æ¿ç±» (PathPanel)
```python
class PathPanel:
    """è·¯å¾„å¯¼èˆªé¢æ¿"""

    def __init__(self, parent, width=300):
        self.frame = ttk.Frame(parent, width=width)
        self.frame.pack(fill=tk.BOTH, expand=True)

        # æ ‡é¢˜
        ttk.Label(self.frame, text="å½“å‰æ’æŸ¥è·¯å¾„", font=("Arial", 12, "bold")).pack(pady=10)

        # è·¯å¾„æ˜¾ç¤ºåŒºåŸŸ
        self.path_frame = ttk.Frame(self.frame)
        self.path_frame.pack(fill=tk.BOTH, expand=True, padx=10)

        # è·¯å¾„é¡¹å®¹å™¨
        self.path_items = []
        self.current_path = []

    def update_path(self, path: List[str]):
        """æ›´æ–°è·¯å¾„æ˜¾ç¤º"""
        # æ¸…é™¤ç°æœ‰è·¯å¾„é¡¹
        for item in self.path_items:
            item.destroy()
        self.path_items.clear()

        self.current_path = path

        # åˆ›å»ºè·¯å¾„é¡¹
        for i, path_item in enumerate(path):
            # ç¡®å®šå›¾æ ‡å’Œæ ·å¼
            if i == len(path) - 1:
                # å½“å‰é¡¹
                icon = "â—‰"
                style = "Current.TLabel"
            else:
                # çˆ¶çº§é¡¹
                icon = "ğŸ“"
                style = "Parent.TLabel"

            # åˆ›å»ºè·¯å¾„é¡¹
            item_frame = ttk.Frame(self.path_frame)
            item_frame.pack(fill=tk.X, pady=2)

            # ç¼©è¿›
            indent = "  " * i
            label = ttk.Label(
                item_frame,
                text=f"{indent}{icon} {path_item}",
                style=style
            )
            label.pack(anchor=tk.W)

            # ç»‘å®šç‚¹å‡»äº‹ä»¶ï¼ˆéå½“å‰é¡¹å¯ç‚¹å‡»ï¼‰
            if i < len(path) - 1:
                label.bind("<Button-1>", lambda e, level=i: self._on_path_clicked(level))
                label.config(cursor="hand2")

            self.path_items.append(label)

    def _on_path_clicked(self, level: int):
        """è·¯å¾„é¡¹ç‚¹å‡»äº‹ä»¶"""
        # è¿™é‡Œå¯ä»¥æ·»åŠ ç‚¹å‡»å›è°ƒåˆ°æ§åˆ¶å™¨
        print(f"ç‚¹å‡»äº†è·¯å¾„å±‚çº§: {level}")

    def clear(self):
        """æ¸…é™¤è·¯å¾„æ˜¾ç¤º"""
        for item in self.path_items:
            item.destroy()
        self.path_items.clear()
        self.current_path.clear()
```

#### 3.1.3 è¯¦æƒ…é¢æ¿ç±» (DetailPanel)
```python
class DetailPanel:
    """è¯¦æƒ…æ˜¾ç¤ºé¢æ¿"""

    def __init__(self, parent, height=200):
        self.frame = ttk.Frame(parent, height=height)
        self.frame.pack(fill=tk.BOTH, expand=True)
        self.frame.pack_propagate(False)

        # æ ‡é¢˜
        ttk.Label(self.frame, text="å½“å‰æ’æŸ¥è¯¦æƒ…", font=("Arial", 12, "bold")).pack(pady=10)

        # è¯¦æƒ…å†…å®¹åŒºåŸŸ
        self.content_frame = ttk.Frame(self.frame)
        self.content_frame.pack(fill=tk.BOTH, expand=True, padx=10)

        # åˆ›å»ºè¯¦æƒ…æ ‡ç­¾
        self.create_detail_labels()

    def create_detail_labels(self):
        """åˆ›å»ºè¯¦æƒ…æ ‡ç­¾"""
        # ç°è±¡
        ttk.Label(self.content_frame, text="ç°è±¡:", font=("Arial", 10, "bold")).pack(anchor=tk.W, pady=(5, 2))
        self.status_label = ttk.Label(self.content_frame, text="-")
        self.status_label.pack(anchor=tk.W, padx=(20, 0))

        # æè¿°
        ttk.Label(self.content_frame, text="æè¿°:", font=("Arial", 10, "bold")).pack(anchor=tk.W, pady=(10, 2))
        self.describe_label = ttk.Label(self.content_frame, text="-", wraplength=400)
        self.describe_label.pack(anchor=tk.W, padx=(20, 0))

        # ä¼˜å…ˆçº§å’Œç‰ˆæœ¬
        info_frame = ttk.Frame(self.content_frame)
        info_frame.pack(anchor=tk.W, pady=(10, 0))

        ttk.Label(info_frame, text="ä¼˜å…ˆçº§:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        self.priority_label = ttk.Label(info_frame, text="-")
        self.priority_label.pack(side=tk.LEFT, padx=(10, 20))

        ttk.Label(info_frame, text="ç‰ˆæœ¬:", font=("Arial", 10, "bold")).pack(side=tk.LEFT)
        self.version_label = ttk.Label(info_frame, text="-")
        self.version_label.pack(side=tk.LEFT, padx=(10, 0))

        # ä¸Šçº§å…³è”
        ttk.Label(self.content_frame, text="ä¸Šçº§:", font=("Arial", 10, "bold")).pack(anchor=tk.W, pady=(10, 2))
        self.parent_label = ttk.Label(self.content_frame, text="-")
        self.parent_label.pack(anchor=tk.W, padx=(20, 0))

    def update_content(self, checklist_item: ChecklistItem):
        """æ›´æ–°è¯¦æƒ…å†…å®¹"""
        self.status_label.config(text=checklist_item.status)
        self.describe_label.config(text=checklist_item.describe)
        self.priority_label.config(text=str(checklist_item.priority))
        self.version_label.config(text=checklist_item.version)

        # è¿™é‡Œå¯ä»¥æ ¹æ®å®é™…æƒ…å†µè®¾ç½®ä¸Šçº§ä¿¡æ¯
        self.parent_label.config(text="å¾…å®ç°")

    def clear(self):
        """æ¸…é™¤è¯¦æƒ…å†…å®¹"""
        self.status_label.config(text="-")
        self.describe_label.config(text="-")
        self.priority_label.config(text="-")
        self.version_label.config(text="-")
        self.parent_label.config(text="-")
```

#### 3.1.4 Checklisté¢æ¿ç±» (ChecklistPanel)
```python
class ChecklistPanel:
    """Checklistç¡®è®¤é¢æ¿"""

    def __init__(self, parent):
        self.frame = ttk.Frame(parent)
        self.frame.pack(fill=tk.BOTH, expand=True)

        # æ ‡é¢˜
        ttk.Label(self.frame, text="Checklistç¡®è®¤", font=("Arial", 12, "bold")).pack(pady=10)

        # æ»šåŠ¨åŒºåŸŸ
        self.create_scrollable_area()

        # å½“å‰checklisté¡¹
        self.current_checklist = []
        self.checklist_widgets = []

        # äº‹ä»¶å›è°ƒ
        self.on_excluded = None
        self.on_confirmed = None

    def create_scrollable_area(self):
        """åˆ›å»ºå¯æ»šåŠ¨åŒºåŸŸ"""
        # åˆ›å»ºCanvaså’ŒScrollbar
        self.canvas = tk.Canvas(self.frame)
        scrollbar = ttk.Scrollbar(self.frame, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas)

        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )

        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=scrollbar.set)

        # å¸ƒå±€
        self.canvas.pack(side="left", fill="both", expand=True, padx=(10, 0))
        scrollbar.pack(side="right", fill="y")

        # ç»‘å®šé¼ æ ‡æ»šè½®
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)

    def _on_mousewheel(self, event):
        """é¼ æ ‡æ»šè½®äº‹ä»¶"""
        self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")

    def update_checklist(self, checklist: List[ChecklistItem]):
        """æ›´æ–°checklistæ˜¾ç¤º"""
        # æ¸…é™¤ç°æœ‰ç»„ä»¶
        self.clear_checklist()

        self.current_checklist = checklist

        # åˆ›å»ºæ–°çš„checklisté¡¹
        for i, item in enumerate(checklist):
            self.create_checklist_item(item, i)

    def create_checklist_item(self, item: ChecklistItem, index: int):
        """åˆ›å»ºå•ä¸ªchecklisté¡¹"""
        item_frame = ttk.Frame(self.scrollable_frame)
        item_frame.pack(fill=tk.X, padx=10, pady=5)

        # ä¼˜å…ˆçº§æ ‡ç­¾
        priority_color = self._get_priority_color(item.priority)
        priority_label = ttk.Label(
            item_frame,
            text=f"[{item.priority}]",
            foreground=priority_color,
            font=("Arial", 9, "bold")
        )
        priority_label.pack(side=tk.LEFT, padx=(0, 5))

        # æ’é™¤å¤é€‰æ¡†
        exclude_var = tk.BooleanVar(value=item.excluded)
        exclude_check = ttk.Checkbutton(
            item_frame,
            text="",
            variable=exclude_var,
            command=lambda: self._on_exclude_clicked(item, exclude_var.get())
        )
        exclude_check.pack(side=tk.LEFT, padx=5)

        # ç°è±¡æ–‡æœ¬
        status_label = ttk.Label(
            item_frame,
            text=item.status,
            font=("Arial", 10)
        )
        status_label.pack(side=tk.LEFT, padx=5)

        # ç¡®è®¤æŒ‰é’®
        confirm_btn = ttk.Button(
            item_frame,
            text="ç¡®è®¤",
            command=lambda: self._on_confirm_clicked(item),
            width=8
        )
        confirm_btn.pack(side=tk.RIGHT, padx=5)

        # æè¿°æ–‡æœ¬
        describe_label = ttk.Label(
            self.scrollable_frame,
            text=f"    {item.describe}",
            font=("Arial", 9),
            foreground="gray",
            wraplength=500
        )
        describe_label.pack(fill=tk.X, padx=(50, 10), pady=(0, 10))

        # ä¿å­˜ç»„ä»¶å¼•ç”¨
        widget_info = {
            'frame': item_frame,
            'exclude_var': exclude_var,
            'status_label': status_label,
            'confirm_btn': confirm_btn,
            'describe_label': describe_label
        }
        self.checklist_widgets.append(widget_info)

    def _get_priority_color(self, priority: int) -> str:
        """æ ¹æ®ä¼˜å…ˆçº§è·å–é¢œè‰²"""
        if priority >= 9:
            return "red"
        elif priority >= 7:
            return "orange"
        elif priority >= 5:
            return "blue"
        else:
            return "gray"

    def _on_exclude_clicked(self, item: ChecklistItem, excluded: bool):
        """æ’é™¤å¤é€‰æ¡†ç‚¹å‡»äº‹ä»¶"""
        item.excluded = excluded
        if self.on_excluded:
            self.on_excluded(item)

    def _on_confirm_clicked(self, item: ChecklistItem):
        """ç¡®è®¤æŒ‰é’®ç‚¹å‡»äº‹ä»¶"""
        if self.on_confirmed:
            self.on_confirmed(item)

    def clear_checklist(self):
        """æ¸…é™¤checklistæ˜¾ç¤º"""
        for widget_info in self.checklist_widgets:
            widget_info['frame'].destroy()
            widget_info['describe_label'].destroy()

        self.checklist_widgets.clear()
        self.current_checklist.clear()

    def update_item_status(self, item: ChecklistItem):
        """æ›´æ–°é¡¹ç›®çŠ¶æ€æ˜¾ç¤º"""
        for i, current_item in enumerate(self.current_checklist):
            if current_item == item:
                widget_info = self.checklist_widgets[i]
                widget_info['exclude_var'].set(item.excluded)

                # æ›´æ–°æ ·å¼
                if item.excluded:
                    widget_info['status_label'].config(foreground="gray")
                else:
                    widget_info['status_label'].config(foreground="black")

                break
```

#### 3.1.5 è§£å†³æ–¹æ¡ˆé¢æ¿ç±» (SolutionPanel)
```python
class SolutionPanel:
    """è§£å†³æ–¹æ¡ˆæ˜¾ç¤ºé¢æ¿"""

    def __init__(self, parent, height=150):
        self.frame = ttk.Frame(parent, height=height)
        self.frame.pack(fill=tk.X, pady=(5, 0))
        self.frame.pack_propagate(False)

        # åˆ›å»ºæ ‡é¢˜
        title_frame = ttk.Frame(self.frame)
        title_frame.pack(fill=tk.X, padx=10, pady=5)

        ttk.Label(title_frame, text="è§£å†³æ–¹æ¡ˆ", font=("Arial", 12, "bold")).pack(side=tk.LEFT)

        # æ¸…é™¤æŒ‰é’®
        self.clear_btn = ttk.Button(
            title_frame,
            text="æ¸…é™¤",
            command=self.clear,
            width=8
        )
        self.clear_btn.pack(side=tk.RIGHT)

        # å†…å®¹æ˜¾ç¤ºåŒºåŸŸ
        self.content_frame = ttk.Frame(self.frame)
        self.content_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 5))

        # åˆ›å»ºæ–‡æœ¬æ˜¾ç¤º
        self.text_widget = tk.Text(
            self.content_frame,
            wrap=tk.WORD,
            height=8,
            font=("Consolas", 10)
        )
        self.text_widget.pack(fill=tk.BOTH, expand=True)

        # æ»šåŠ¨æ¡
        scrollbar = ttk.Scrollbar(self.text_widget, orient="vertical")
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.text_widget.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=self.text_widget.yview)

        # è®¾ç½®åªè¯»
        self.text_widget.config(state=tk.DISABLED)

    def show_solution(self, solution: str):
        """æ˜¾ç¤ºè§£å†³æ–¹æ¡ˆ"""
        self.text_widget.config(state=tk.NORMAL)
        self.text_widget.delete(1.0, tk.END)

        # æ ¼å¼åŒ–è§£å†³æ–¹æ¡ˆ
        formatted_solution = self._format_solution(solution)
        self.text_widget.insert(tk.END, formatted_solution)

        self.text_widget.config(state=tk.DISABLED)

    def _format_solution(self, solution: str) -> str:
        """æ ¼å¼åŒ–è§£å†³æ–¹æ¡ˆæ–‡æœ¬"""
        # ç®€å•çš„æ ¼å¼åŒ–ï¼Œå¯ä»¥æ ¹æ®éœ€è¦æ‰©å±•
        lines = solution.split('\n')
        formatted_lines = []

        for line in lines:
            if line.strip():
                if line.strip().startswith(('1.', '2.', '3.', '4.', '5.', '6.', '7.', '8.', '9.')):
                    # æ­¥éª¤åˆ—è¡¨
                    formatted_lines.append(f"  {line}")
                elif line.strip().startswith(('-', 'â€¢', '*')):
                    # é¡¹ç›®ç¬¦å·
                    formatted_lines.append(f"  {line}")
                else:
                    # æ™®é€šæ–‡æœ¬
                    formatted_lines.append(line)
            else:
                formatted_lines.append("")

        return '\n'.join(formatted_lines)

    def clear(self):
        """æ¸…é™¤è§£å†³æ–¹æ¡ˆæ˜¾ç¤º"""
        self.text_widget.config(state=tk.NORMAL)
        self.text_widget.delete(1.0, tk.END)
        self.text_widget.config(state=tk.DISABLED)
```

### 3.2 é…ç½®ç®¡ç†æ¨¡å—

#### 3.2.1 é…ç½®åŠ è½½å™¨ (ConfigLoader)
```python
import json
from pathlib import Path

class ConfigLoader:
    """é…ç½®åŠ è½½å™¨"""

    def __init__(self, config_file: str = "config.json"):
        self.config_file = Path(config_file)
        self.config = self._load_default_config()
        self.load_config()

    def _load_default_config(self) -> dict:
        """åŠ è½½é»˜è®¤é…ç½®"""
        return {
            "data_directory": "data",
            "window_width": 1200,
            "window_height": 800,
            "theme": "default",
            "font_family": "Microsoft YaHei",
            "font_size": 10,
            "auto_save": True,
            "debug_mode": False
        }

    def load_config(self):
        """ä»æ–‡ä»¶åŠ è½½é…ç½®"""
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    file_config = json.load(f)
                self.config.update(file_config)
            except Exception as e:
                print(f"åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥: {e}")

    def save_config(self):
        """ä¿å­˜é…ç½®åˆ°æ–‡ä»¶"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥: {e}")

    def get(self, key: str, default=None):
        """è·å–é…ç½®å€¼"""
        return self.config.get(key, default)

    def set(self, key: str, value):
        """è®¾ç½®é…ç½®å€¼"""
        self.config[key] = value
        if self.get("auto_save", True):
            self.save_config()
```

è¿™ä¸ªæŠ€æœ¯è®¾è®¡æ–¹æ¡ˆæä¾›äº†ï¼š

1. **å®Œæ•´çš„æ•°æ®æ¨¡å‹**ï¼šåŸºäºPython dataclassçš„å¼ºç±»å‹è®¾è®¡
2. **åˆ†å±‚ç³»ç»Ÿæ¶æ„**ï¼šæ¸…æ™°çš„è¡¨ç¤ºå±‚ã€ä¸šåŠ¡é€»è¾‘å±‚ã€æ•°æ®è®¿é—®å±‚
3. **è¯¦ç»†çš„UIç»„ä»¶è®¾è®¡**ï¼šåŒ…æ‹¬æ‰€æœ‰ä¸»è¦ç•Œé¢ç»„ä»¶çš„å®Œæ•´å®ç°
4. **é…ç½®ç®¡ç†**ï¼šæ”¯æŒé…ç½®æ–‡ä»¶åŠ è½½å’Œä¿å­˜

è¿™ä¸ºåç»­çš„Python GUIå®ç°æä¾›äº†å®Œæ•´çš„æŠ€æœ¯åŸºç¡€ã€‚